/*************************************************************
- 《C专家编程》学习日志
- 作者：谢荣桢
- 版本：V1.0
*************************************************************/
--------------------------------------
2018/10/04（16:25）：
    第一章 C：穿越时空的迷雾
    1.1 C语言的史前阶段
    1.2 C语言的早期体验
        1.数组下标从0而不是1开始
        2.C语言的基本数据类型直接与底层硬件相应
        3.auto关键字显然是摆设
            auto是默认的变量内存分配方式，只对创建符号表入口的编译器设计者有意义。
        4.表达式中的数组名可以看作是指针
            注：数组和指针并不是在任何情况下都是等效的
        5.float被自动扩展为double
            注：在ANSIC中不在如此
        6.不允许嵌套函数(函数内部包含另一个函数的定义)
            简化了编译器，并稍微提高了C程序的运行时组织结构
        7.register关键字
            这个关键字定义的变量将存放到寄存器中，简化了编译器，但把包袱丢给了程序员

    1.3 标准I/O库和C预处理器
        C预处理的3个主要功能
            1.字符串替换
                通常用于为常量提供一个符号名
            2.头文件包含
                一般性的声明可以被分离到头文件中，并且可以被许多源文件使用。
            3.通用代码模板的扩展
                宏(marco)在连续几个调用中所接收的类型可以不同(宏的实际参数只是按照原样输出)
                空格会对扩展的结果造成很大的影响
                    #define a(y) a_expanded(y)
                    a(x);
                被扩展为
                    a_expanded(x);
                而
                    #define a (y) a_expanded (y)
                    a(x);
                则被扩展为
                    (y) a_expanded (y) (x)

    1.4 K&R C
        《The C programming Langauage》(中文版为《C程序设计语言》)

    1.5 今日之ANSI C
    1.6 它很棒，但它符合标准吗
        1.不可移植的代码(unportable code)
            (1).由编译器定义的(implementation-defined)，不同的编译器可能不同
                例：当整型数向右移位时，要不要扩展符号位。
            (2).未确定的(unspecified),在某些正确情况下的做法，标准并未明确规定怎么做(即不在ANSI C标准内的做法)
                例：参数求值的顺序
        2.坏代码(bad code)
            (1).未定义的(undefined),在某些不正确情况下的做法，但标准为规定怎么做
                例：当一个有符号整数溢出该采取什么行动
            (2).约束条件(a constraint),必须遵守的限制或要求
                例：求余操作符(%)的操作数必须属于整型，在非整型数据上使用%操作符会引发一条错误信息
        3.可移植的代码(portable code)
            (1).严格遵循标准的(strictly-conforming)
                只使用已确定的特性
                不突破任何由编译器实现的限制
                不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出
            (2).遵循标准的(conforming),可以依赖一些某种编译器特有的不可移植的特性，但移植时需对其进行修改。

    1.7 编译限制
        ANSI C 编译器必须能够支持
            1.在函数定义中形参数量的上限至少可以达到31个
            2.在函数调用时实参数量的上限至少可以达到31个
            3.在一条源代码行里至少可以有509个字符
            4.在表达式中至少可以支持32层嵌套的括号
            5.long int的最大值不得小于2147483647(即long型整数不得低于32位)

    1.8 ANSI C标准的结构

    *1.9 阅读ANSI C标准，寻找乐趣和裨益

    **  training1.c中的代码编译后会发出一条警告信息
            line 5:warning:argument is incompatible with prototype
        这是因为char **argv与形参const char **p不相容,但实参char *s与const char *p是相容的。
        const char **是一个没有限定符的指针类型，它的类型是“指向有const限定符的char类型的指针的指针”
        char **也是一个没有限定符的指针类型，它的类型是“指向无限定符的char类型的指针的指针”
        因为char **argv指向char *argv,而const char **p指向const char*p,被赋值的对象p带有限定符违反了第6.3.2.2节的约束条件。

        在ANSI C标准第6.3.2.2节中讲述约束条件的小结中的一段话说明参数传递过程类似于赋值。
        所以，除非一个类型为char **的值可以赋给一个const char **类型的对象。
        而在标准第6.3.16.1节描述了下列约束条件：
            要使上述的赋值形式合法，必须满足下列条件之一：
            两个操作数都是指向有限定符或无限定符的相容类型的指针，左边指针所指向的类型必须具有右边指针所指向类型的全部限定符
        所以实参char*与const char*匹配。
        合法的原因如例：
            char *cp;
            const char *ccp;
            ccp = cp;
            左操作数所指向的类型具有右操作数所指向类型的限定符(无)，再加上自身的限定符(const)。
        注：反过来赋值cp = ccp;会报之前的编译警告(argument is incompatible with prototype)

    1.10 “安静的改变”究竟有多少安静
        K&R C采用无符号保留(unsigned preserving)原则，就是当一个无符号类型与int或更小的整型(如char)混合使用时，结果类型是无符号类型，这会使
    一个负数丢失符号位。
        ANSI C采用值保留(value preserving)原则，即
            当执行算术运算时，操作数的类型如果不同，就会发生转换。数据类型一般朝着浮点精度更高、长度更长的方向装换，整型数如果转换为signed不会
        丢失信息，就转换为signed，否则转换为unsigned。
        training2.c的代码在ANSI C和K&R C编译器中将打印不同的信息。

        training3.c中的if语句结果不为真，原因是TOTAL_ELEMENTS所定义的值是unsigned int类型(sizeof函数返回的类型是无符号数)，
    导致d被升级为unsigned int类型，-1转换成unsigned int的结果将是一个非常大的正整数，导致表达式值为假。要修正这个bug，需要对
    TOTAL_ELEMENTS进行强制类型转换。
        if(d <= (int)TOTAL_ELEMENTS - 2)

        对无符号类型的建议
            1.尽量不要使用无符号类型，以免增加不必要的复杂性。
            2.尽量使用有符号类型，这样在设计升级混合类型的复杂细节时，不必担心如trainin3.c那样的边界情况(如-1被翻译为非常大的正数)
            3.只有在使用位段和二进制掩码时，才可以用无符号数。应该在表达式中使用强制类型转换，使操作数均为有符号数或无符号数，避免编译器来选择结果的类型。

        容易混淆的const
            关键字const并不能把变量变成常量。只是表示这个变量不能被赋值，即只读的，但不能防止通过程序的内部(甚至是外部)的方法来修改这个值。
            const最有用之处是限定函数的形参，使得函数不会修改实参指针所指的数据，但其他函数却可能修改它。
            training4.c揭示了const存在的问题，limitp是一个指向常量类型的指针，其不能用于修改整型数，但这个指针本身的值却可以改变(即可以指向不同的地址)，
        这回造成一些罕见的错误。
            建议：
                const和*的组合通常只用于在数组形式的参数中模拟传值调用。

--------------------------------------
2018/10/06（15:15）：
    第二章 这不是Bug，而是语言特性
    2.1 这关语言特性何事，在Fortran里这就是Bug呀
        NUL:用于结束一个ASCII字符串
        NULL：用于表示空指针。

    2.2 多做之过
        2.2.1 由于存在fall through，switch语句会带来麻烦
            switch语句的一般形式如下：
                switch(表达式)
                {
                    case 常量表达式：零条或多条语句
                           default：零条或多条语句
                    case 常量表达式：零条或多条语句
                }
            如果没有default，而且所有的case均不匹配，那整条switch语句便什么都不做。
            一个遵循标准的C编译器至少允许一条swtich语句中有257个case标签(ANSI C标准，第5.2.4.1节)--256个可能的值加上EOF

        **  switch存在的问题：
                1.对case可能出现的值太过于放纵
                    例如：可以在switch的左花括号之后声明一些变量，从而进行一些局部存储的分配，而不报错。
                    但这些变量并没有用处，它们不会被执行，因为switch语句是从匹配表达式的case开始执行。
                    training2.1.c表明了这一问题。
                    所以如果需要一些临时变量最好放在块的开始处。

                2.switch语句内部的任何语句都可以加上case标签，并在执行时跳转到那里。
                    正如training2.2.c所展示的错误，当把default的“l”错写成数字1，并不会报错，
                实际效果相当于default子句并不存在与switch语句中。
                    注：const关键字并不真正表示常量。

                3.switch语句不会再每个case标签后面的语句执行完毕后自动中止。
                一旦执行某个case语句，程序将会依次执行后面所有的case，除非遇到break语句。
                这称之为"fall through"。详情如training2.3.c所示。

        2.2.2 粉笔也成了可用的硬件
            ANSI C引入的一个新特性：
                相邻的字符串常量将被自动合并成一个字符串的约定
                    这省掉了过去在书写多行信息时必须在行末加“\”的做法，但这种自动合并意味着
                字符串数组在初始化时，如果不小心漏掉了一个逗号，编译器将不会发出错误信息，而是
                悄无声息地把两个字符串合并在一起。
                training2.4.c表明了这一问题。

        2.2.3 太多的缺省可见性
            定义C函数时，在缺省情况下函数的名字是全局可见的，即加不加extern效果一样。
            如果想限制对这个函数的访问，必须加个static关键字
                function apple() {/* 在任何地方均可见 */}
                extern function pear() {/* 在任何地方均可见 */}
                static function turnip() {/* 在这个文件之外不可见 */}
            作用域过宽的问题常见于库中：一个库需要让一个对象在另一个库中可见。唯一的办法
            是让它变得全局可见，但这样一来，它对于链接到该库的所有对象都是可见的了。

    2.3 误做之过
        2.3.1 骆驼背上的重载
            许多符号是被“重载”的――――在不同的上下文环境里有不同的意义。

            C语言的符号重载
            1.static：在函数内部，表示该变量的值在各个调用间一直保持延续性，即只做一次初始化
                      在函数这一级，表示该函数只对本文件可见
            2.extern：用于函数定义，表示全局可见(属于冗余的)
                      用于变量，表示它在其他地方定义
            3.void  ：作为函数的返回类型，表示不返回任何值
                      在指针声明中，表示通用指针的类型
                      位于参数列表这种，表示没有参数
            4.*     ：乘法运算符
                      用于指针，间接引用
                      在声明中，表示指针
            5.&     ：位的AND操作符
                      取地址操作符
            6.<<=   ：左移复合赋值运算符
            7.<     ：小于运算符
                      #include指令的左定界符
            8.()    ：在函数定义中，包围形式参数表
                      调用一个函数
                      改变表达式的运算次序
                      将值转换为其他类型(强制类型转换)
                      定义带参数的宏
                      包围sizeof操作符的操作数(如果它是类型名)

            p38页的apple = sizeof(int) * p;经测试为int的长度乘以p，若p为指针会报错。

        2.3.2 “有些运算符的优先级是错误的”
            C语言运算符优先级存在的问题
            详见P38页表2-2

            注：表达式中如果有布尔操作、算术运算、位操作等混合计算，始终应该在适当的地方加上括号。
                结合性是仲裁者，在几个操作符具有相同的优先级时决定先执行哪一个。

        2.3.3 早期gets()中的Bug导致了Internet蠕虫
            gets()函数从流中读入一个字符串，但其无法检查缓冲区的空间，故如果函数调用者提供一个指向堆栈的指针，
        并且gets()函数读入的字符数量超过缓冲区的空间，多出来的字符会继续写入到堆栈，覆盖原先的内容。
            所以推荐用fgets()彻底取代gets(),fgets()函数对读入的字符数设置了一个限制，这样就不会超出缓冲区范围。

    2.4 少做之过
        2.4.1 用户名中若有字母f,便不能收到邮件。
        2.4.2 空格――――最后的领域
            1.“\”字符可用于对一些字符进行“转义”，包括newline(这里指回车键)
                即\和新行之间如果多了空格会造成问题，并且很难被发现。
                这通常出现在用于转义连续多行的宏定义
            2.如果将所有的空格都弃之不用，也会陷入麻烦。
                例如: z = y+++x;
                    ANSI C规定如果下一个标记有超过一种的解释方案，编译器将选取能组成最长字符序列的方案。
                    所以，上例将解析为z = y++ +x;
                    但 z = y+++++x;会有麻烦，按照前面的策略将解析为z = y++ ++ +x;这将引起一个编译错误：“++操作符迷失于空格间”
                    即使编译器能推断(从理论上说)唯一有效的编排方式是 z = y++ + ++x;还是会出现编译错误。
                    training2.6.c说明了这个问题。
            3.当程序员有两个指向int的指针并想对两个int数据执行除法运算时，
                ratio = *x/*y;
            但编译器会报错：出现了语法错误。问题出在除法运算符“/”与“*”操作符之间缺少空格。
            编译器误认为/*是一个注释的开始部分。

        2.4.3 C++的另一种注释形式
            "//"注释符
            对于a //*
                //*/ b
            在C语言中表示a/b，但在C++中表示a。
            在training2.7.c中可知“//”注释符可用的情况下上例结果为a。

        2.4.4 编译器日期被破坏
            p48页的例子。
            当函数返回的是一个指向局部变量的指针时，当控制流离开局部变量的范围，变量将失效，无法得知变量的内容。
            解决方案
            1.返回一个指向字符串常量的指针(最简单的解决方案，适用于无需计算字符串的内容)
                例：return "Only";
            2.使用全局声明的数组
            3.使用静态数组(static关键字)
            4.显示的分配一些内存，保存返回的值
                但要注意释放内存，在函数内分配后，很容易忘记在使用函数后释放该内存，造成严重的问题。
            5.要求调用者分配内存来保存函数的返回值。
                例：buffer = malloc(size);
                    fuc(buffer,size);
                    free(buffer);

        2.4.5 lint程序绝不应该被分离出来
            lint程序是程序的道德准则。当你做错事时，它会告诉你那里不对。应该始终使用lint程序，按照它的道德准则办事。
